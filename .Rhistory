Param <- def_param()
Param$paramGroundTruth$NumReps <- c(5)
# Param$paramDigest$EnrichmentEfficiency <- 0.8
# Param$paramDigest$ModificationLoss <- 0.5
# Param$paramMSRun$PercDetectedVal <- 0.5
Param$paramMSRun$MSNoise <- 1
Param$paramDataAnalysis$ProtSummarization <- "median"
Param$paramDataAnalysis$ProtSummarization <- "median"
Param$paramDataAnalysis$IncludeModPep <- F
Param$paramDataAnalysis$SharedPep <- F
#####################
## Run the simulations
#####################
allBs <- run_sims(Param, Config = proteomaker)
#####################
## Get the results of an individual simulation
#####################
res <- get_simulation(allBs[[1]]$Param, Config = proteomaker, stage = "DataAnalysis")
#####################
## Make matrix of benchmarks and save
#####################
benchmarks <- matrix_benchmarks(allBs, )
Param$paramDataAnalysis$SharedPep <- T
#####################
## Run the simulations
#####################
allBs <- run_sims(Param, Config = proteomaker)
devtools::clean_vignettes()
devtools::build_vignettes()
devtools::check()
tools::showNonASCIIfile("R/00_BatchRunFuncs.R")
devtools::documentation()
devtools::document()
devtools::check()
devtools::document()
devtools::run_examples()
devtools::build_vignettes()
devtools::clean_dll()
devtools::build_vignettes()
devtools::document()                  # regenerate NAMESPACE + Rd
devtools::install(dependencies = TRUE, build_vignettes = TRUE)
.Last.error
# Load ProteoMaker
library(ProteoMaker)
# Configure the paths and settings
proteomaker_config <- set_proteomaker(
# Default path to the Proteomes folder in the ProteoMaker package
fastaFilePath =  system.file("Proteomes", package = "ProteoMaker"),
# Default path to the temporary directory
resultFilePath = paste0(tempdir(), "/SimulatedDataSets"),
# Increase to the number of cores you want to use.
# Large numbers can lead to considerably higher RAM usage
cores = 1,
# Should work on all operation systems. If you have problems, try "FORK" instead
clusterType = "PSOCK",
# Run statistical tests on the simulated data to compare ground truth with simulated values
runStatTests = TRUE,
# Calculate all benchmarks for the simulated data
calcAllBenchmarks = TRUE
)
# Generate default parameters
Param <- def_param()
# Example of overwriting default values
Param$paramGroundTruth$PathToFasta <- "fasta_example.fasta"
Param$paramGroundTruth$PercExpressedProt <- 1.0
# Param$paramGroundTruth$NumReps <- c(3)
# Param$paramGroundTruth$NumCond <- 5
# Param$paramGroundTruth$FracModProt <- 0.5
# Param$paramGroundTruth$PTMTypes <- "ph"
# Param$paramGroundTruth$PTMTypesMass <- c(79.966331)
# Param$paramGroundTruth$PTMTypesDist <- c(1)
# Param$paramGroundTruth$PTMMultipleLambda <- c(0.1)
# Param$paramGroundTruth$ModifiableResidues <- list(c("S", "T", "Y"))
# Param$paramGroundTruth$ModifiableResiduesDistr <- list(c(0.86,0.13, 0.01))
Param$paramGroundTruth$NumReps <- c(3:5)
# Param$paramProteoformAb$QuantNoise <- seq(0.1, 0.9, 0.5)
# Param$paramProteoformAb$DiffRegFrac <- c(0.1, 0.3, 0.5)
# Param$paramProteoformAb$DiffRegMax <- seq(0.5, 2, 0.5)
# Param$paramDigest$Enzyme <- "trypsin"
# Param$paramDigest$PropMissedCleavages <- 0.01
# Param$paramDigest$MaxNumMissedCleavages <- 4
# Param$paramDigest$PepMinLength <- 7
# Param$paramDigest$PepMaxLength <- 30
# Param$paramMSRun$PercDetectedPep <- seq(0.1, 0.5, 0.1)
# Param$paramDataAnalysis$MinUniquePep <- 100
# Generate default parameters
Param <- def_param()
# Example of overwriting default values
Param$paramGroundTruth$PathToFasta <- "fasta_example.fasta"
Param$paramGroundTruth$PercExpressedProt <- 1.0
# Param$paramGroundTruth$NumReps <- c(3)
# Param$paramGroundTruth$NumCond <- 5
# Param$paramGroundTruth$FracModProt <- 0.5
# Param$paramGroundTruth$PTMTypes <- "ph"
# Param$paramGroundTruth$PTMTypesMass <- c(79.966331)
# Param$paramGroundTruth$PTMTypesDist <- c(1)
# Param$paramGroundTruth$PTMMultipleLambda <- c(0.1)
# Param$paramGroundTruth$ModifiableResidues <- list(c("S", "T", "Y"))
# Param$paramGroundTruth$ModifiableResiduesDistr <- list(c(0.86,0.13, 0.01))
Param$paramGroundTruth$NumReps <- c(3:5)
# Param$paramProteoformAb$QuantNoise <- seq(0.1, 0.9, 0.5)
# Param$paramProteoformAb$DiffRegFrac <- c(0.1, 0.3, 0.5)
# Param$paramProteoformAb$DiffRegMax <- seq(0.5, 2, 0.5)
# Param$paramDigest$Enzyme <- "trypsin"
# Param$paramDigest$PropMissedCleavages <- 0.01
# Param$paramDigest$MaxNumMissedCleavages <- 4
# Param$paramDigest$PepMinLength <- 7
# Param$paramDigest$PepMaxLength <- 30
# Param$paramMSRun$PercDetectedPep <- seq(0.1, 0.5, 0.1)
# Param$paramDataAnalysis$MinUniquePep <- 100
# Run the simulations
allBs <- run_sims(Param, proteomaker_config)
# Run the simulations
allBs <- run_sims(Param, proteomaker_config)
# Run the simulations
allBs <- run_sims(Param, proteomaker_config)
# Retrieve results}
res <- get_simulation(allBs[[1]]$Param, proteomaker_config)
# Generate the benchmark matrix
benchmarks <- matrix_benchmarks(allBs, proteomaker_config)
write.csv(benchmarks, file = paste0(proteomaker_config$resultFilePath, "/allBenchmarks.csv"))
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
traceback()
benchmarks
devtools::load_all()
write.csv(benchmarks, file = paste0(proteomaker_config$resultFilePath, "/allBenchmarks.csv"))
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
plotCI(3:5, 10:12, uiw = NA)
plotCI(3:5, 10:12, uiw = NA,    gap = 0,
sfrac = 0.02)
plotCI(as.character(3:5), 10:12, uiw = NA,    gap = 0,
+        sfrac = 0.02)
plotCI(as.character(3:5), 10:12, uiw = NA,    gap = 0, sfrac = 0.02)
plotCI(as.character(3:5), 10:12, uiw = NA,    gap = 1, sfrac = 0.02)
plotCI((3:5), 10:12, uiw = NA,    gap = 0, sfrac = 0.02)
benchmarks
benchmarks$NumReps
benchmarks$NumCond
devtools::load_all()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
visualize_benchmarks(benchmarks, ref_par = "NumCond")
visualize_benchmarks(benchmarks, ref_par = "NumReps")
#' conf <- set_proteomaker(resultFilePath = tempdir())
#' results <- run_sims(def_param(), conf)
#' benchmark_matrix <- matrix_benchmarks(results, conf)
#' visualize_benchmarks(benchmark_matrix, ref_par = "NumReps")
#'
#' @importFrom colorspace qualitative_hcl
#' @importFrom lattice levelplot
#' @importFrom gplots plotCI
#'
#' @export
visualize_benchmarks <- function(benchmatrix,
benchmarks = NULL,
ref_par = "WrongIDs",
fullrange = FALSE,
cols = NULL,
errorbar = FALSE) {
# Require at least one row in benchmatrix
if (nrow(benchmatrix) < 1) {
stop("No data available for visualization.")
}
ref_par <- make.names(ref_par)
colnames(benchmatrix) <- make.names(colnames(benchmatrix))
titles <- c(
numPeptides = "I: #Total peptides (mod+unmod)",
numProteins = "II: #Proteins (from peptides)",
propUniquePep = "III: Fraction unique peptides (prot-specific)",
uniqueStrippedPep = "IV: #Stripped sequences",
percMissingPep = "V: % Missing peptide values",
aucDiffRegPeptides.FDR_limma.2.vs.1.AUC = "VI: Peptide AUC (truth vs FDR)",
tprPep0.01.FDR_limma.2.vs.1.TPR = "VII: TPR peptide (FDR < 0.01)",
tprPep0.05.FDR_limma.2.vs.1.TPR = "VIII: TPR peptide (FDR < 0.05)",
tFDRPep0.01.FDR_limma.2.vs.1.tFDR = "IX: True FDR (peptides, 0.01)",
tFDRPep0.05.FDR_limma.2.vs.1.tFDR = "X: True FDR (peptides, 0.05)",
propMisCleavedPeps.0 = "XI: No miscleavage fraction",
dynRangePep = "XII: Dynamic range (peptides)",
meanSquareDiffFCPep = "XIII: Fold-change error (peptides)",
sdWithinRepsPep = "XIV: Replicate SD (regulated peptides)",
skewnessPeps = "XV: Skewness (peptides)",
kurtosisPeps = "XVI: Kurtosis (peptides)",
sdPeps = "XVII: Overall SD (peptides)",
numQuantProtGroups = "XVIII: #Quantified proteins",
propUniqueProts = "XIX: Fraction unique proteins",
percMissingProt = "XX: Fraction missing protein values",
meanPepPerProt = "XXI: Peptides per protein",
aucDiffRegProteins.FDR_PolySTest.2.vs.1.AUC = "XXII: Protein AUC (truth vs FDR)",
tprProt0.01.FDR_PolySTest.2.vs.1.TPR = "XXIII: TPR protein (FDR < 0.01)",
tprProt0.05.FDR_PolySTest.2.vs.1.TPR = "XXIV: TPR protein (FDR < 0.05)",
tFDRProt0.01.FDR_PolySTest.2.vs.1.tFDR = "XXV: True FDR (proteins, 0.01)",
tFDRProt0.05.FDR_PolySTest.2.vs.1.tFDR = "XXVI: True FDR (proteins, 0.05)",
meanSquareDiffFCProt = "XXVII: Fold-change error (proteins)",
sdWithinRepsProt = "XXVIII: Replicate SD (regulated proteins)",
propMisCleavedProts = "XXIX: Fraction miscleaved proteins",
propDiffRegWrongIDProt0.01.FDR_PolySTest.2.vs.1 = "XXX: Fraction wrong-ID (proteins, 0.01)",
propDiffRegWrongIDProt0.05.FDR_PolySTest.2.vs.1 = "XXXI: Fraction wrong-ID (proteins, 0.05)",
skewnessProts = "XXXII: Skewness (proteins)",
kurtosisProts = "XXXIII: Kurtosis (proteins)",
sdProts = "XXXIV: Overall SD (proteins)",
numProteoforms = "XXXV: #Proteoforms",
meanProteoformsPerProt = "XXXVI: Proteoforms per protein",
numModPeptides = "XXXVII: #Modified peptides",
propModAndUnmodPep = "XXXVIII: Fraction modified with unmodified match",
aucDiffRegAdjModPep = "XXXIX: AUC (adj. mod. peptides)",
tprAdjModPep0.01 = "XL: TPR (adj. mod. peptides, 0.01)",
tprAdjModPep0.05 = "XLI: TPR (adj. mod. peptides, 0.05)",
tFDRAdjModPep0.01 = "XLII: True FDR (mod. peptides, 0.01)",
tFDRAdjModPep0.05 = "XLIII: True FDR (mod. peptides, 0.05)",
propDiffRegPepWrong0.01.FDR_PolySTest.2.vs.1 = "XLIV: Fraction wrongly significant (mod. peptides, 0.01)",
propDiffRegPepWrong0.05.FDR_PolySTest.2.vs.1 = "XLV: Fraction wrongly significant (mod. peptides, 0.05)",
percOverlapModPepProt = "XLVI: Fraction mod peptides with protein quant",
meanSquareDiffFCModPep = "XLVII: Fold-change error (mod. peptides)"
)
# maximal ranges of each parameters for alternative visualization
ranges <-  lapply(titles, function(x) c(0, NA))
names(ranges) <- names(titles)
ranges[["propUniquePep"]] <-
ranges[["aucDiffRegPeptides.FDR_limma.2.vs.1.AUC"]] <-
ranges[["tprPep0.01.FDR_limma.2.vs.1.TPR"]] <-
ranges[["tprPep0.05.FDR_limma.2.vs.1.TPR"]] <-
ranges[["tFDRPep0.01.FDR_limma.2.vs.1.tFDR"]] <-
ranges[["tFDRPep0.05.FDR_limma.2.vs.1.tFDR"]] <-
ranges[["propDiffRegWrongIDProt0.01.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegWrongIDProt0.05.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegPepWrong0.01.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegPepWrong0.05.FDR_PolySTest.2.vs.1"]] <-
ranges[["propUniqueProts"]] <-
ranges[["aucDiffRegProteins.FDR_PolySTest.2.vs.1.AUC"]] <-
ranges[["tprProt0.01.FDR_PolySTest.2.vs.1.TPR"]] <-
ranges[["tprProt0.05.FDR_PolySTest.2.vs.1.TPR"]] <-
ranges[["tFDRProt0.01.FDR_PolySTest.2.vs.1.tFDR"]] <-
ranges[["tFDRProt0.05.FDR_PolySTest.2.vs.1.tFDR"]] <-
ranges[["propMisCleavedPeps.0"]] <-
ranges[["propMisCleavedProts"]] <-
ranges[["propModAndUnmodPep"]] <-
ranges[["propDiffRegPepWrong0.01.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegPepWrong0.05.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegWrongIDProt0.01.FDR_PolySTest.2.vs.1"]] <-
ranges[["propDiffRegWrongIDProt0.05.FDR_PolySTest.2.vs.1"]] <-
ranges[["propMisCleavedPeps.0"]] <- c(0, 1)
ranges[["percMissingPep"]] <- c(0, 100)
ranges[["skewnessPeps"]] <-
ranges[["kurtosisPeps"]] <-
ranges[["skewnessProts"]] <-
ranges[["kurtosisProts"]] <- c(NA, NA)
titles_params <- c(
NumCond = "Number of conditions",
NumReps = "Number of replicates",
PathToFasta = "Path to FASTA file",
PathToProteinList = "Path to protein list (optional)",
PercExpressedProt = "Fraction of expressed proteins",
FracModProt = "Fraction of proteins to be modified",
PropModPerProt = "Max #Modifications per protein",
PTMMultipleLambda = "Poisson lambda for multiple PTMs",
RemoveNonModFormFrac = "Fraction without non-modified form",
PTMTypes = "PTM types",
PTMTypesDistr = "PTM type distribution",
PTMTypesMass = "PTM mass shifts",
ModifiableResidues = "Modifiable residues",
ModifiableResiduesDistr = "Modifiable residue distribution",
QuantNoise = "Quantification noise (SD)",
DiffRegFrac = "Fraction of differentially regulated",
DiffRegMax = "Max fold-change (log2)",
UserInputFoldChanges_NumRegProteoforms = "#User-specified regulated proteoforms",
UserInputFoldChanges_RegulationFC = "User-defined fold change",
AbsoluteQuanMean = "Mean absolute quantity",
AbsoluteQuanSD = "SD of absolute quantity",
ThreshNAQuantileProt = "NA removal quantile threshold",
Enzyme = "Digestion enzyme",
PropMissedCleavages = "Proportion with missed cleavages",
MaxNumMissedCleavages = "Max missed cleavages",
PepMinLength = "Min peptide length",
PepMaxLength = "Max peptide length",
LeastAbundantLoss = "Fraction of least abundant removed",
EnrichPTM = "Enriched PTM type",
EnrichmentLoss = "Enrichment loss",
EnrichmentEfficiency = "Enrichment efficiency",
EnrichmentQuantDiff = "Quant difference due to enrichment",
EnrichmentNoise = "Enrichment noise",
ModificationLoss = "Loss of modified peptides",
PercDetectability = "Fraction of peptides detected (model)",
PercDetectedVal = "Fraction of detected intensities",
WeightDetectVal = "Intensity-dependence of detection",
MSNoise = "Instrumental noise",
WrongIDs = "Wrong identification rate",
WrongLocalizations = "Wrong localization rate",
MaxNAPerPep = "Max NAs per peptide",
ProtSummarization = "Protein summarization method",
MinUniquePep = "Min unique peptides per protein",
StatPaired = "Paired testing enabled"
)
# Setting fixed color code
dark_colors <- colorspace::qualitative_hcl(n = length(titles), palette = "Dark 3")
M <- matrix(1:100, nrow = 10, byrow = TRUE)
M <- M[M <= length(dark_colors) & M > 0]
dark_colors <- dark_colors[as.vector(M)]
names(dark_colors) <- names(titles)
# Setting fixed character for pch
pch.vals <- rep(c(1, 16, 17, 15, 3, 4, 8), length.out = length(titles))
names(pch.vals) <- names(titles)
# Allow at most two parameters
if (length(ref_par) > 2) {
stop("Please provide at most two parameters for visualization.")
}
# Assign titles to parameters
for (i in ref_par) {
if (!(i %in% names(titles_params))) {
stop(paste("Parameter name", i, "is not correct."))
}
}
params <- titles_params[ref_par]
# Setting benchmarking metrics to be plotted
if(length(benchmarks) == 0) {
titles <- titles[1:12]
} else if (is.character(benchmarks)) {
# Check if the provided benchmarks are valid
benchmarks <- make.names(benchmarks)
for (i in benchmarks) {
if (!(i %in% names(titles))) {
stop(paste("Benchmark name", i, "is not correct."))
}
}
titles <- titles[benchmarks]
} else  if (is.numeric(benchmarks)) {
# check for range of indices
if (max(benchmarks) > length(titles)) {
stop(paste("Too many benchmarks selected. Please select a maximum of", length(titles)))
}
titles <- titles[benchmarks]
# check whether in benchmatrix
if (length(titles) > 0) {
for(i in names(titles)) {
if (!(i %in% names(benchmatrix))) {
warning(paste("Benchmark name", i, "is not available as benchmark. Will be removed"))
titles <- titles[-which(names(titles) == i)]
}
}
}
} else {
stop("Please provide a character vector of benchmark names or numeric vector of indices.")
}
benchmarks <- names(titles)
dark_colors <- dark_colors[benchmarks]
pch.vals <- pch.vals[benchmarks]
n_plots <- length(titles)
# Always 4x34 to ensure sizes
plotmfrow <- c(4, 4)
par(mfrow=plotmfrow, cex.main=0.9, cex.lab = 0.75, cex.axis = 0.7,
mgp = c(1.5, 0.3, 0), mar=c(3, 3, 1.5, 1.5), xpd = TRUE, font.main = 2)
# Generate a dark qualitative color palette
if (!is.null(cols)) {
dark_colors <- rep(cols, length.out = n_plots)
}
# Loop through all metrics
for (i in names(titles)) {
col <- dark_colors[i]
pch.use <- pch.vals[i]
# Single plots when having one parameter
if (length(ref_par) == 1) {
# change to full range if set
myrange <- range(benchmatrix[, i], na.rm = TRUE)
if (fullrange) {
if(!is.na(ranges[[i]][1])) {
myrange[1] <- ranges[[i]][1]
}
if(!is.na(ranges[[i]][2])) {
myrange[2] <- ranges[[i]][2]
}
}
if (all(is.finite(range(benchmatrix[, i], na.rm=T)))) {
x <- benchmatrix[, ref_par]
y <- benchmatrix[, i]
uiw <- NA
if (errorbar) {
# Calculate upper and lower error bounds if errorbar is TRUE
uiw <- unlist(by(benchmatrix[, i], benchmatrix[, ref_par], function(x) {
if (length(x) > 1) {
return(sd(x, na.rm = TRUE))
} else {
return(NA)
}
}))
y <- unlist(by(benchmatrix[, i], benchmatrix[, ref_par], function(x) {
if (length(x) > 1) {
return(mean(x, na.rm = TRUE))
} else {
return(NA)
}
}))
x <- unique(benchmatrix[, ref_par])
if (any(is.character(x))) {
xf <- factor(x, levels = unique(x))   # preserve order
x  <- as.numeric(xf)
}
}
gplots::plotCI(x ,y ,
uiw = uiw,
gap = 0,
xaxt = "n",
sfrac = 0.02,
xlab = params, ylab = i,
pch = pch.use, col = col, cex = 1.5, cex.lab = 1, cex.axis = 1,
ylim = myrange)
axis(1, at = x, labels = levels(xf), las = 2)
abline(h = pretty(benchmatrix[, i]), col = "gray90", lty = "dotted")
abline(v = pretty(benchmatrix[, ref_par]), col = "gray90", lty = "dotted")
title(main = paste0(titles[i]),
col.main = col, font.main = 2)
} else {
plot(benchmatrix[, ref_par], rep(0, length(benchmatrix[, i])), type = "n",
xlab = params, ylab = i,
main = paste0(titles[i]),
col.main = col, font.main = 2,
myrange)
}
} else {
# colormaps showing the benchmarks in a 2-dim plot as colors
# Create matrix from benchmatrix ref_par columns with values from i
# and plot it
if (length(ref_par) == 2) {
x_vals <- sort(unique(benchmatrix[, ref_par[1]]))
y_vals <- sort(unique(benchmatrix[, ref_par[2]]))
z_mat <- matrix(NA, nrow = length(x_vals), ncol = length(y_vals))
for (j in 1:nrow(benchmatrix)) {
x_idx <- which(x_vals == benchmatrix[j, ref_par[1]])
y_idx <- which(y_vals == benchmatrix[j, ref_par[2]])
z_mat[x_idx, y_idx] <- benchmatrix[j, i]
}
# Define a color ramp
n_colors <- 100
col_ramp <- colorRampPalette(c("white", col))
image_colors <- col_ramp(n_colors)
zlim <- range(z_mat, na.rm=T)
if(any(!is.finite(zlim))) {
zlim <- c(0, 0)
}
# Plot image
image(x = x_vals, y = y_vals, z = z_mat,
col = image_colors, zlim = zlim,
xlab = params[1], ylab = params[2], axes = TRUE)
# Colorized title
title(main = paste0(titles[i]),
col.main = col, font.main = 2)
# Expand singleton axes to avoid collapsed plots
if (length(x_vals) == 1) {
x_vals <- x_vals + c(-0.5, 0.5)
}
if (length(y_vals) == 1) {
y_vals <- y_vals + c(-0.5, 0.5)
}
# Add colorbar along right side
bar_x <- max(x_vals, na.rm=T) -  diff(range(x_vals, na.rm=T)) * 0.5
bar_w <- diff(range(x_vals, na.rm=T)) * 0.03
rect_x <- c(bar_x, bar_x + bar_w)
# Color bar segments
color_steps <- length(image_colors)
bar_y_vals <- seq(min(y_vals, na.rm=T), max(y_vals, na.rm=T), length.out = color_steps + 1)
for (k in 1:color_steps) {
rect(rect_x[1], bar_y_vals[k], rect_x[2], bar_y_vals[k+1],
col = image_colors[k], border = NA)
}
# rectangle around all rectangles with white border
rect(rect_x[1], min(y_vals, na.rm=T), rect_x[2], max(y_vals, na.rm=T),
col = NA, border = "#333333", lwd = 0.5)
# Add legend labels on the colorbar
legend_labels <- pretty(zlim, n = 3)
if (diff(range(zlim, na.rm=T)) > 0) {
legend_pos <- approx(zlim, range(bar_y_vals, na.rm=T), xout = legend_labels)$y
text(x = rect_x[2] + 0.02 * diff(range(x_vals, na.rm=T)),
y = legend_pos,
labels = round(legend_labels, 2),
cex = 0.6, adj = 0)
}
}
}
}
# Reset plotting layout
par(mfrow = c(1, 1), cex.main = 1.2, cex.lab = 1, cex.axis = 1, xpd = FALSE,
font.main = 1)
}
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
devtools::load_all()
rm(list = c("visualize_benchmarks"))
devtools::load_all()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
visualize_benchmarks
any(is.character(benchmarks$NumReps))
x <- benchmarks$NumReps
x <- unique(benchmatrix[, ref_par])
x <- unique(x)
x
any(is.character(x))
xf <- factor(x, levels = unique(x))   # preserve order
xf
x  <- as.numeric(xf)
x
devtools::load_all()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, ref_par = "NumReps")
devtools::load_all()
visualize_benchmarks(benchmarks, ref_par = "NumReps")
devtools::build_vignettes()
devtools::load_all()
devtools::check()
devtools::clean_vignettes()
devtools::build_vignettes()
devtools::check()
