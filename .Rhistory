param_t <- param_table()
param_names <- rownames(param_t)
param_names
BenchMatrix <- benchmarks
#' the specified simulation.
#'
#' @importFrom plotly plot_ly subplot
#' @importFrom gplots colorpanel
#' @importFrom dplyr %>%
#' @export
#'
#' @examples
#' benchmarks <- matrix_benchmarks(run_sims(def_param(), set_phosfake()), set_phosfake())
#' visualize_benchmarks(benchmarks, current_row = 1)
visualize_benchmarks <- function(BenchMatrix, current_row = 1) {
# get parameter names
param_t <- param_table()
param_names <- rownames(param_t)
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
for (i in 1:ncol(BenchMatrix)) {
tt <- unlist(BenchMatrix[, i])
if (all(is.na(tt))) {
to_del <- c(to_del, i)
}
}
if(length(to_del) > 0)
BenchMatrix <- BenchMatrix[, -to_del]
BenchMatrix[is.na(BenchMatrix)] <- 0
# remove column QuantColnames if it exists
if ("QuantColnames" %in% colnames(BenchMatrix)) {
BenchMatrix <- BenchMatrix[, -which(colnames(BenchMatrix) == "QuantColnames")]
}
tBenchMatrix <- BenchMatrix
nr <- 2# nrow(BenchMatrix)
# convert characters to factors
if (is.null(ncol(BenchMatrix))) {
message("No benchmarks available for this simulation.")
return()
}
for (i in 1:ncol(BenchMatrix)) {
tt <- BenchMatrix[, i]
if (is.numeric(tt)) {
BenchMatrix[, i] <- round(tt, 2)
}
if (is.character(tt) || is.factor(tt)) {
tt <- as.numeric(as.factor(tt))
}
tt <- tt - min(tt, 0)
tt <- tt / max(tt, na.rm = T)
tt[is.na(tt)] <- 0
tBenchMatrix[, i] <- unlist(tt)
}
# Define color palette
color_palette <- colorpanel(100, "#AA3333", "#3333AA")
# Create plots
plots <- list()
sim <- current_row
if (is.numeric(sim))
sim <- rownames(BenchMatrix)[sim]
dat <- tBenchMatrix[sim, ]
dat <- sapply(dat, function(x) {
if (is.numeric(x)) {
dat <- round(x, 2)
}
if (!is.numeric(x)) {
x <- 0
}
x
})
dat2 <- BenchMatrix[sim, ]
dat2 <- sapply(dat2, function(x) {    if (is.numeric(x)) {
x <- round(x, 2)
}
x
})
plot <- plotly::plot_ly(
x = names(dat),
y = as.numeric(dat),
type = 'bar',
marker = list(
color = color_palette[as.numeric(dat) * 99 + 1]
),
text = as.character(dat2),
textposition = 'auto',
hoverinfo = 'text'
) %>%
plotly::layout(
title = paste("hash:", sim),
yaxis = list(title = 'Normalized values', range = c(0, 1), tickfont = list(size = 18/nr), titlefont = list(size = 20/nr)),
xaxis = list(title = '', tickangle = -45, tickfont = list(size = 16/nr)),
margin = list(t = 100, b = 100, l = 100, r = 100),
showlegend = FALSE
)
param_plot <- plot_params(param_values, sim)
# Combine all plots into a subplot
subplot(param_plot, plot, nrows = 2, shareX = TRUE, shareY = TRUE,
margin = 0.01, titleX = TRUE, titleY = TRUE) %>%
plotly::layout(showlegend = FALSE)
}
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
for (i in 1:ncol(BenchMatrix)) {
tt <- unlist(BenchMatrix[, i])
if (all(is.na(tt))) {
to_del <- c(to_del, i)
}
}
ncol(benchmarks)
ncol(BenchMatrix)
BenchMatrix <- benchmarks
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
reds
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
BenchMatrix
length(BenchMatrix)
ncol(BenchMatrix)
devtools::load_all()
rm(list = c("visualize_benchmarks")
)
devtools::load_all()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, 2)
devtools::check()
devtools::test()
devtools::load_all()
devtools::test()
Param <- def_param()
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
benchmarks <- run_sims(Param, phosfake_config)
benchmatrix <- matrix_benchmarks(benchmarks, phosfake_config)
result <- suppressWarnings(visualize_benchmarks(benchmatrix, current_row = 1))
expect_true(inherits(result, "plotly"))
visualize_benchmarks(benchmatrix, current_row = 1)
benchmatrix
# get parameter names
param_t <- param_table()
param_names <- rownames(param_t)
benchmatrix
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
nrow(BenchMatrix)
BenchMatrix <- benchmatrix
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
reds
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
if (is.null(ncol(BenchMatrix)))
message("No benchmarks have been calculated for this simulation.")
return()
devtools::load_all()
devtools::check()
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
library(BEclear)
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
library(wrProteo)
?wrProteo::readMaxQuantPeptides
?wrProteo::readWombatNormFile
devtools::load_all()
#####################
## Paths and directories
#####################
phosfake_config <- set_phosfake(fastaFilePath = system.file("Proteomes", package = "PhosFake"),
resultFilePath = "SimulatedDataSets",
cores = 4, clusterType = "PSOCK",
runStatTests = F,
calcAllBenchmarks = T
)
#####################
## Create default list of testing parameters
#####################
Param <- def_param()
# Param$paramProteoformAb$QuantNoise <- seq(0.1, 0.9, 0.5)
# Param$paramProteoformAb$DiffRegFrac <- c(0.1, 0.3, 0.5)
# Param$paramProteoformAb$DiffRegMax <- seq(0.5, 2, 0.5)
# Param$paramDigest$Enzyme <- "trypsin"
# Param$paramDigest$PropMissedCleavages <- 0.01
# Param$paramDigest$MaxNumMissedCleavages <- 4
# Param$paramDigest$PepMinLength <- 7
# Param$paramDigest$PepMaxLength <- 30
Param$paramMSRun$PercDetectedVal <- 0.9
Param$paramMSRun$PercDetectability <- 1
Param$paramMSRun$WrongIDs <- 0
#####################
## Run the simulations
#####################
allBs <- run_sims(Param, phosfake_config)
#####################
## Get the results of an individual simulation
#####################
res <- get_simulation(allBs[[1]]$Param, phosfake_config)
Param$paramProteoformAb$QuantNoise <- seq(0.1, 0.9, 0.5)
# Param$paramProteoformAb$DiffRegFrac <- c(0.1, 0.3, 0.5)
# Param$paramProteoformAb$DiffRegMax <- seq(0.5, 2, 0.5)
# Param$paramDigest$Enzyme <- "trypsin"
# Param$paramDigest$PropMissedCleavages <- 0.01
# Param$paramDigest$MaxNumMissedCleavages <- 4
# Param$paramDigest$PepMinLength <- 7
# Param$paramDigest$PepMaxLength <- 30
Param$paramMSRun$PercDetectedVal <- 0.9
Param$paramMSRun$PercDetectability <- 1
Param$paramMSRun$WrongIDs <- 0
#####################
## Run the simulations
#####################
allBs <- run_sims(Param, phosfake_config)
#####################
## Get the results of an individual simulation
#####################
res <- get_simulation(allBs[[1]]$Param, phosfake_config)
ttt <- gather_all_sims(phosfake_config)
ttt
phosfake_config
ttt <- gather_all_sims(phosfake_config, "MSRun")
ttt
ttt[[1]]
devtools::load_all()
ttt <- gather_all_sims(phosfake_config, "MSRun")
ttt
names(ttt)
matrix_benchmarks(ttt, phosfake_config)
get_simulation(ttt[[1]], phosfake_config)
ttt[[1]]
get_simulation(ttt[[1]][[1]], phosfake_config)
allBs
get_simulation(ttt[[1]][[1]], phosfake_config, "MSRun")
?get
devtools::load_all()
ttt <- gather_all_sims(phosfake_config, "MSRun")
get_simulation(ttt[[1]], phosfake_config, "MSRun")
ttt
get_simulation(ttt[[1]], phosfake_config, "MSRun")
get_simulation(ttt[[1]]$Param, phosfake_config, "MSRun")
matrix_benchmarks(ttt)
test_that("gather_all_sims returns correct structure", {
# Mock configuration with a temp directory
temp_dir <- tempdir()
config <- list(resultFilePath = temp_dir)
# Create mock RData files
Param <- list(param1 = 1, param2 = 2)
Benchmarks <- list(metric1 = 0.95, metric2 = 0.85)
save(Param, Benchmarks, file = file.path(temp_dir, "outputDataAnalysis_test1.RData"))
Param <- list(param3 = 3, param4 = 4)
# Save without Benchmarks
save(Param, file = file.path(temp_dir, "outputDataAnalysis_test2.RData"))
# Run the function to gather all simulations
all_results <- gather_all_sims(config, stage = "DataAnalysis")
# Check that the output is a list
expect_type(all_results, "list")
# Check that it contains two elements (for the two RData files)
expect_equal(length(all_results), 2)
# Check that both have the correct hashes
expect_true("test1" %in% names(all_results))
expect_true("test2" %in% names(all_results))
# Check that test1 contains both Param and Benchmarks
expect_true("Param" %in% names(all_results$test1))
expect_true("Benchmarks" %in% names(all_results$test1))
# Check that test2 only contains Param (no Benchmarks)
expect_true("Param" %in% names(all_results$test2))
expect_false("Benchmarks" %in% names(all_results$test2))
# Check that the contents of Param and Benchmarks match what was saved
expect_equal(all_results$test1$Param, Param)
expect_equal(all_results$test1$Benchmarks, Benchmarks1)
expect_equal(all_results$test2$Param, Param2)
})
test_that("gather_all_sims returns correct structure", {
# Mock configuration with a temp directory
temp_dir <- tempdir()
config <- list(resultFilePath = temp_dir)
# Create mock RData files
Param <- list(param1 = 1, param2 = 2)
Benchmarks <- list(metric1 = 0.95, metric2 = 0.85)
save(Param, Benchmarks, file = file.path(temp_dir, "outputDataAnalysis_test1.RData"))
Param <- list(param3 = 3, param4 = 4)
# Save without Benchmarks
save(Param, file = file.path(temp_dir, "outputDataAnalysis_test2.RData"))
# Run the function to gather all simulations
all_results <- gather_all_sims(config, stage = "DataAnalysis")
# Check that the output is a list
expect_type(all_results, "list")
# Check that it contains two elements (for the two RData files)
expect_equal(length(all_results), 2)
# Check that both have the correct hashes
expect_true("test1" %in% names(all_results))
expect_true("test2" %in% names(all_results))
# Check that test1 contains both Param and Benchmarks
expect_true("Param" %in% names(all_results$test1))
expect_true("Benchmarks" %in% names(all_results$test1))
# Check that test2 only contains Param (no Benchmarks)
expect_true("Param" %in% names(all_results$test2))
expect_false("Benchmarks" %in% names(all_results$test2))
# Check that the contents of Param and Benchmarks match what was saved
expect_equal(all_results$test1$Param, Param)
expect_equal(all_results$test1$Benchmarks, Benchmarks)
expect_equal(all_results$test2$Param, Param)
})
Param <- def_param()
Param$paramGroundTruth$NumReps <- 5
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
benchmarks <- run_sims(Param, phosfake_config)
sims <- gather_all_sims(phosfake_config)
sims
test_that("gather_all_sims returns correct structure", {
Param <- def_param()
Param$paramGroundTruth$NumReps <- 5
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
benchmarks <- run_sims(Param, phosfake_config)
sims <- gather_all_sims(phosfake_config)
expect_true(length(sims[[1]]$Benchmarks) > 0)
expect_true(length(sims[[1]]$Param) > 0)
sims <- gather_all_sims(phosfake_config, stage = "MSRun")
expect_true(length(sims[[1]]$Benchmarks) == 0)
expect_true(length(sims[[1]]$Param) > 0)
})
test_that("gather_all_sims handles empty directories", {
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
# Mock configuration with a different temp directory (empty)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
# Run the function on an empty directory
all_results_empty <- gather_all_sims(config_empty, stage = "DataAnalysis")
# Check that the result is an empty list
expect_equal(length(all_results_empty), 0)
})
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
# Mock configuration with a different temp directory (empty)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
# Run the function on an empty directory
all_results_empty <- gather_all_sims(config_empty, stage = "DataAnalysis")
test_that("gather_all_sims handles empty directories", {
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
# Mock configuration with a different temp directory (empty)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
# Run the function on an empty directory
all_results_empty <- gather_all_sims(phosfake_config, stage = "DataAnalysis")
# Check that the result is an empty list
expect_equal(length(all_results_empty), 0)
})
test_that("gather_all_sims handles empty directories", {
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
# Mock configuration with a different temp directory (empty)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
# Run the function on an empty directory
all_results_empty <- gather_all_sims(phosfake_config, stage = "DataAnalysis")
# Check that the result is an empty list
expect_equal(length(all_results_empty), 0)
})
devtools::check()
library(wrProteo)
wrProteo::readWombatNormFile("/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/stand_prot_quant_mergedproline.csv")
wrProteo::readWombatNormFile("/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/stand_prot_quant_mergedproline.csv")
read.csv("/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/stand_prot_quant_mergedproline.csv")
wrProteo::readWombatNormFile("/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/stand_prot_quant_mergedproline.csv")
?readWombatNormFile
wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", /home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/")
wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/")
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline")
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline", sdrf="../PXD009203.sdrf_corrected.tsv")
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline", sdrf="../PXD009203.sdrf_corrected.tsv")
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline", sdrf="PXD009203.sdrf_corrected.tsv")
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline", suplAnnotFile ="PXD009203.sdrf_corrected.tsv")
names(A)
names(A$quant)
names(A$annot)
names(A$counts)
A
names(A$quant)
A$raw
head(A$raw)
tail(A$raw)
tail(A$sampleSetup
)
A$quantNotes
A$notes
A <- wrProteo::readWombatNormFile("stand_prot_quant_mergedproline.csv", "/home/veit/devel/Bioinformatics/ELIXIR_EDAM/WOMBAT-P/WOMBAT-P_Processed/PXD009203/0.9.2/", "proline", suplAnnotFile ="PXD009203.sdrf_corrected.tsv")
tail(A$sampleSetup)
?readMaxQuantFile
sessionInfo()
A <- read.csv("https://ncdrisc.org/downloads/bp/NCD_RisC_Lancet_2016_BP_age_standardised_countries.csv")
A
head(A)
View(A)
knitr::opts_chunk$set(echo = TRUE)
show_sol <- TRUE
# Generate random data representing Cytokine Alpha concentrations in COVID-19 patients
data <- rnorm(5000, 5, 1)
# Create a histogram to visualize the distribution
hist(data, 50)
# Calculate and plot the mean concentration
dmean <- mean(data)
abline(v = dmean, col = "red")
# Calculate and plot the median concentration
dmedian <- median(data)
abline(v = dmedian, col = "green")
# Calculate and plot the minimum concentration
dmin <- min(data)
abline(v = dmin, col = "blue")
# Generate random data representing Cytokine Alpha concentrations in COVID-19 patients
data <- rnorm(5000, 5, 1)
# Create a histogram to visualize the distribution
hist(data, 50)
# Calculate and plot the mean concentration
dmean <- mean(data)
abline(v = dmean, col = "red")
# Calculate and plot the median concentration
dmedian <- median(data)
abline(v = dmedian, col = "green")
# Calculate and plot the minimum concentration
dmin <- min(data)
abline(v = dmin, col = "blue")
# Calculate and plot the maximum concentration
dmax <- max(data)
abline(v = dmax, col = "blue")
# Calculate and plot one standard deviation above and below the mean
dsd <- sd(data)
abline(v = dmean + dsd)
abline(v = dmean - dsd)
A <- read.csv("http://computproteomics.bmb.sdu.dk/BMB539Data/FlowCytoData.csv")
A <- read.csv("http://computproteomics.bmb.sdu.dk/BMB539Data/FlowCytoData.csv")
par(mfrow=c(2,2))
hist(A$X18s.RNA,100,main="18s RNA",xlab="abundance")
hist(A$abl,100,main="abl",xlab="abundance")
hist(A$bcr,100,main="bcr",xlab="abundance")
hist(A$bcr,100,main="bcr",xlab="abundance")
par(mfrow=c(1,1))
par(mfrow=c(2,2))
hist(A$X18s.RNA,100,main="18s RNA",xlab="abundance")
hist(A$abl,100,main="abl",xlab="abundance")
hist(A$bcr,100,main="bcr",xlab="abundance")
A <- read.csv("http://computproteomics.bmb.sdu.dk/BMB539Data/FlowCytoData.csv")
par(mfrow=c(2,2))
hist(A$X18s.RNA,100,main="18s RNA",xlab="abundance")
hist(A$abl,100,main="abl",xlab="abundance")
hist(A$bcr,100,main="bcr",xlab="abundance")
par(mfrow=c(1,1))
hist(1:10)
par(cex.lab=1.3, cex.axis=1.5, cex.main=1.5, mar=c(8.1, 4.1, 4.1, 2.1))
hist(1:10)
comics_factor <- comics
pca_out <- prcomp(as.matrix(comics), scale.=TRUE)
# Plot percentages on total variance as barplot
barplot(pca_out$sdev^2/sum(pca_out$sdev^2) * 100, border=0, col="lightblue", main="Variance plot", xlab="Principal Component", ylab="Variance in %", names.arg=1:ncol(comics))
comics <- read.csv("assets/dc-wikia-data.csv")
rownames(comics) <- comics$name
comics <- comics[,c(5,6,7,8,10,11,13)]
# remove all rows with NA
comics[comics == ""] <- NA
comics <- comics[complete.cases(comics),]
for (i in 1:ncol(comics))
comics[,i] <- as.factor(comics[,i])
head(comics)
table(comicss$ALIGN)
table(comics$ALIGN)
as.factor(comics$ALIGN)
table(as.factor(comics$ALIGN))
table(as.factor(comics$SEX))
?factor
label(as(factor(comics$SEX)))
labels(as(factor(comics$SEX)))
head(comic)
head(comics)
head(unclass(comics))
head(levels(comics))
head(comics$ALIGN)
as.numeric(head(comics$ALIGN))
as.numeric(head(comics$SEX))
(head(comics$SEX))
as.numeric(head(comics$ALIGN, 100))
(head(comics$ALIGN, 100))
par(cex.lab=1.3, cex.axis=1.5, cex.main=1.5, mar=c(8.1, 4.1, 4.1, 2.1))
comics_factor <- comics
for (i in 1:ncol(comics))
comics[,i] <- as.numeric(comics[,i])
pca_out <- prcomp(as.matrix(comics), scale.=TRUE)
# Plot percentages on total variance as barplot
barplot(pca_out$sdev^2/sum(pca_out$sdev^2) * 100, border=0, col="lightblue", main="Variance plot", xlab="Principal Component", ylab="Variance in %", names.arg=1:ncol(comics))
print(head(comics)
)
