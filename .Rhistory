ls()
?max
read.csv("xxx.csv", header = TRUE)
read.csv("xxx.csv", header = TRUE)
setwd("devel/Bioinformatics/EuBIC/PhosFake/")
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::check()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, 2)
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, 2)
# Install PhosFake
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools", repos = "https://cran.r-project.org")
}
devtools::install_github("veitveit/PhosFake")
# Load PhosFake
library(PhosFake)
# Configure the paths and settings
phosfake_config <- set_phosfake(
# Default path to the Proteomes folder in the PhosFake package
fastaFilePath =  system.file("Proteomes", package = "PhosFake"),
# Default path to the temporary directory
resultFilePath = paste0(tempdir(), "/SimulatedDataSets"),
# Increase to the number of cores you want to use.
# Large numbers can lead to considerably higher RAM usage
cores = 1,
# Should work on all operation systems. If you have problems, try "FORK" instead
clusterType = "PSOCK",
# Run statistical tests on the simulated data to compare ground truth with simulated values
runStatTests = TRUE,
# Calculate all benchmarks for the simulated data
calcAllBenchmarks = TRUE
)
# Generate default parameters
Param <- def_param()
# Example of overwriting default values
Param$paramGroundTruth$PathToFasta <- "fasta_example.fasta"
# Param$paramGroundTruth$NumReps <- c(3)
# Param$paramGroundTruth$NumCond <- 5
# Param$paramGroundTruth$FracModProt <- 0.5
# Param$paramGroundTruth$PTMTypes <- "ph"
# Param$paramGroundTruth$PTMTypesMass <- c(79.966331)
# Param$paramGroundTruth$PTMTypesDist <- c(1)
# Param$paramGroundTruth$PTMMultipleLambda <- c(0.1)
# Param$paramGroundTruth$ModifiableResidues <- list(c("S", "T", "Y"))
# Param$paramGroundTruth$ModifiableResiduesDistr <- list(c(0.86,0.13, 0.01))
Param$paramGroundTruth$NumReps <- c(3:5)
# Param$paramProteoformAb$QuantNoise <- seq(0.1, 0.9, 0.5)
# Param$paramProteoformAb$DiffRegFrac <- c(0.1, 0.3, 0.5)
# Param$paramProteoformAb$DiffRegMax <- seq(0.5, 2, 0.5)
# Param$paramDigest$Enzyme <- "trypsin"
# Param$paramDigest$PropMissedCleavages <- 0.01
# Param$paramDigest$MaxNumMissedCleavages <- 4
# Param$paramDigest$PepMinLength <- 7
# Param$paramDigest$PepMaxLength <- 30
# Param$paramMSRun$PercDetectedPep <- seq(0.1, 0.5, 0.1)
# Param$paramDataAnalysis$MinUniquePep <- 100
# Run the simulations
allBs <- run_sims(Param, phosfake_config)
# Retrieve results}
res <- get_simulation(allBs[[1]]$Param, phosfake_config)
# Generate the benchmark matrix
benchmarks <- matrix_benchmarks(allBs, phosfake_config)
write.csv(benchmarks, file = paste0(phosfake_config$resultFilePath, "/allBenchmarks.csv"))
benchmarks
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, 2)
param_t <- param_table()
param_names <- rownames(param_t)
param_names
BenchMatrix <- benchmarks
#' the specified simulation.
#'
#' @importFrom plotly plot_ly subplot
#' @importFrom gplots colorpanel
#' @importFrom dplyr %>%
#' @export
#'
#' @examples
#' benchmarks <- matrix_benchmarks(run_sims(def_param(), set_phosfake()), set_phosfake())
#' visualize_benchmarks(benchmarks, current_row = 1)
visualize_benchmarks <- function(BenchMatrix, current_row = 1) {
# get parameter names
param_t <- param_table()
param_names <- rownames(param_t)
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
for (i in 1:ncol(BenchMatrix)) {
tt <- unlist(BenchMatrix[, i])
if (all(is.na(tt))) {
to_del <- c(to_del, i)
}
}
if(length(to_del) > 0)
BenchMatrix <- BenchMatrix[, -to_del]
BenchMatrix[is.na(BenchMatrix)] <- 0
# remove column QuantColnames if it exists
if ("QuantColnames" %in% colnames(BenchMatrix)) {
BenchMatrix <- BenchMatrix[, -which(colnames(BenchMatrix) == "QuantColnames")]
}
tBenchMatrix <- BenchMatrix
nr <- 2# nrow(BenchMatrix)
# convert characters to factors
if (is.null(ncol(BenchMatrix))) {
message("No benchmarks available for this simulation.")
return()
}
for (i in 1:ncol(BenchMatrix)) {
tt <- BenchMatrix[, i]
if (is.numeric(tt)) {
BenchMatrix[, i] <- round(tt, 2)
}
if (is.character(tt) || is.factor(tt)) {
tt <- as.numeric(as.factor(tt))
}
tt <- tt - min(tt, 0)
tt <- tt / max(tt, na.rm = T)
tt[is.na(tt)] <- 0
tBenchMatrix[, i] <- unlist(tt)
}
# Define color palette
color_palette <- colorpanel(100, "#AA3333", "#3333AA")
# Create plots
plots <- list()
sim <- current_row
if (is.numeric(sim))
sim <- rownames(BenchMatrix)[sim]
dat <- tBenchMatrix[sim, ]
dat <- sapply(dat, function(x) {
if (is.numeric(x)) {
dat <- round(x, 2)
}
if (!is.numeric(x)) {
x <- 0
}
x
})
dat2 <- BenchMatrix[sim, ]
dat2 <- sapply(dat2, function(x) {    if (is.numeric(x)) {
x <- round(x, 2)
}
x
})
plot <- plotly::plot_ly(
x = names(dat),
y = as.numeric(dat),
type = 'bar',
marker = list(
color = color_palette[as.numeric(dat) * 99 + 1]
),
text = as.character(dat2),
textposition = 'auto',
hoverinfo = 'text'
) %>%
plotly::layout(
title = paste("hash:", sim),
yaxis = list(title = 'Normalized values', range = c(0, 1), tickfont = list(size = 18/nr), titlefont = list(size = 20/nr)),
xaxis = list(title = '', tickangle = -45, tickfont = list(size = 16/nr)),
margin = list(t = 100, b = 100, l = 100, r = 100),
showlegend = FALSE
)
param_plot <- plot_params(param_values, sim)
# Combine all plots into a subplot
subplot(param_plot, plot, nrows = 2, shareX = TRUE, shareY = TRUE,
margin = 0.01, titleX = TRUE, titleY = TRUE) %>%
plotly::layout(showlegend = FALSE)
}
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
for (i in 1:ncol(BenchMatrix)) {
tt <- unlist(BenchMatrix[, i])
if (all(is.na(tt))) {
to_del <- c(to_del, i)
}
}
ncol(benchmarks)
ncol(BenchMatrix)
BenchMatrix <- benchmarks
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
reds
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
BenchMatrix <- BenchMatrix[, !reds]
BenchMatrix
length(BenchMatrix)
ncol(BenchMatrix)
devtools::load_all()
rm(list = c("visualize_benchmarks")
)
devtools::load_all()
# visualize the benchmarks and parameters of the second simulation
visualize_benchmarks(benchmarks, 2)
devtools::check()
devtools::test()
devtools::load_all()
devtools::test()
Param <- def_param()
ll <- list.files(tempdir(), pattern="output", full.names = TRUE)
unlink(ll, recursive = TRUE)
phosfake_config <- set_phosfake(resultFilePath = tempdir())
benchmarks <- run_sims(Param, phosfake_config)
benchmatrix <- matrix_benchmarks(benchmarks, phosfake_config)
result <- suppressWarnings(visualize_benchmarks(benchmatrix, current_row = 1))
expect_true(inherits(result, "plotly"))
visualize_benchmarks(benchmatrix, current_row = 1)
benchmatrix
# get parameter names
param_t <- param_table()
param_names <- rownames(param_t)
benchmatrix
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
nrow(BenchMatrix)
BenchMatrix <- benchmatrix
# Visualize roughly
par(mfrow = c(nrow(BenchMatrix), 1), mar = c(2, 5, 2, 1), xpd = T, oma = c(5, 1, 1, 1))
# Separate parameters and filter for actual values
reds <- colnames(BenchMatrix) %in% param_names
param_values <- BenchMatrix[, reds]
reds
BenchMatrix <- BenchMatrix[, !reds]
to_del <- c()
if (is.null(ncol(BenchMatrix)))
message("No benchmarks have been calculated for this simulation.")
return()
devtools::load_all()
devtools::check()
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
library(BEclear)
shiny::runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
runApp('~/devel/Bioinformatics/DataAnalysis/ShinyApps/OmicsQ')
library(wrProteo)
?wrProteo::readMaxQuantPeptides
?wrProteo::readWombatNormFile
