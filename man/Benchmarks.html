<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ProteoMaker Benchmarks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Benchmarks_files/libs/clipboard/clipboard.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/quarto.js"></script>
<script src="Benchmarks_files/libs/quarto-html/popper.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/anchor.min.js"></script>
<link href="Benchmarks_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Benchmarks_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Benchmarks_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Benchmarks_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Benchmarks_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ProteoMaker Benchmarks</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This document provides a detailed description of the benchmarks used in the ProteoMaker pipeline. ProteoMaker is a tool for generating an in-silico bottom-up LC-MS dataset from proteoforms. The pipeline simulates various stages of the experimental process, from the generation of ground truth data to mass spectrometry (MS) analysis and statistical testing. These benchmarks are essential for comparing the results and evaluating the performance of the pipeline. For more information about the project, visit <a href="https://github.com/computproteomics/ProteoMaker">ProteoMaker on GitHub</a>.</p>
<section id="list-of-benchmarks" class="level2">
<h2 class="anchored" data-anchor-id="list-of-benchmarks">List of Benchmarks</h2>
<p>The following values and distributions are collected and will be used for comparing the results.</p>
<section id="peptide-level" class="level3">
<h3 class="anchored" data-anchor-id="peptide-level">Peptide Level</h3>
<ul>
<li><strong>Total Number of Peptides</strong>: Counts both modified and non-modified peptides. Fixed PTMs are not considered “modified”.</li>
<li><strong>Number of Proteins</strong>: Total number of all proteins, independently whether shared or uniquely identified.</li>
<li><strong>Proportion of Unique Modified and Non-Modified Peptides</strong>: Measures the proportion of peptides that are unique and either modified or non-modified.</li>
<li><strong>Total Number of Unique Stripped Sequences</strong>: Counts the unique sequences after removing modifications.</li>
<li><strong>Percentage Missingness</strong>: Calculates the percentage of missing values in the data.</li>
<li><strong>AUC of ROC Curve for Correct Differentially Regulated Features</strong>: Area under the ROC curve for correctly identifying differentially regulated peptides.</li>
<li><strong>TPR (True Positive Rate)</strong>: Found proportion of correct differentially regulated peptides, with FDR &lt; 0.05/0.01.</li>
<li><strong>True FDR for Estimated FDR</strong>: True false discovery rate for an estimated FDR of 0.01/0.05.</li>
<li><strong>Proportion of Cleaved Peptides</strong>: Proportion of peptides per number of miscleavages.</li>
<li><strong>Retention Time Range</strong>: The range of retention times (max-min).</li>
<li><strong>Dynamic Range</strong>: The dynamic range of peptide intensities on a log2 scale (max-min).</li>
<li><strong>Number of Accepted PSMs</strong>: Count of accepted peptide-spectrum matches, based on scan numbers.</li>
<li><strong>Sum of Squares Residuals Towards Actual Fold-Changes</strong>: Assigns mean fold-change for peptides with multiple assigned fold-changes, only calculated for the first 2 conditions.</li>
<li><strong>Mean of Std. Dev. Within Replicates</strong>: The mean standard deviation within replicates of peptides with actual fold-changes, on a log scale.</li>
<li><strong>Distribution of Quantitative Values (Skewness)</strong>: Measures how asymmetric the distribution of quantitative values is.</li>
<li><strong>Distribution of Quantitative Values (Kurtosis)</strong>: Measures how normal (peaked) the distribution of quantitative values is.</li>
<li><strong>Distribution of Quantitative Values (Standard Deviation)</strong>: Measures how broad the distribution of quantitative values is.</li>
</ul>
</section>
<section id="protein-level" class="level3">
<h3 class="anchored" data-anchor-id="protein-level">Protein Level</h3>
<ul>
<li><strong>Number of Quantified Protein Groups</strong>: Total number of quantified protein groups.</li>
<li><strong>Proportion of Quantified Uniquely Identified Proteins</strong>: Measures the proportion of uniquely identified proteins that are quantified.</li>
<li><strong>Percentage Missingness</strong>: Calculates the percentage of missing values at the protein level.</li>
<li><strong>Distribution of Non-Modified Peptides per Protein</strong>: Summarized by its mean, the distribution of non-modified peptides per protein.</li>
<li><strong>AUC of ROC Curve for Correct Differentially Regulated Features</strong>: Area under the ROC curve for correctly identifying differentially regulated proteins.</li>
<li><strong>True FDR for Estimated FDR</strong>: True false discovery rate for an estimated FDR of 0.01/0.05.</li>
<li><strong>TPR (True Positive Rate)</strong>: Found proportion of correct differentially regulated proteins, with FDR &lt; 0.05/0.01.</li>
<li><strong>Sum of Squares Residuals Towards Actual Fold-Changes</strong>: Takes the first non-zero one in case of multiples.</li>
<li><strong>Dynamic Range</strong>: The dynamic range of protein intensities on a log2 scale (max-min).</li>
<li><strong>Mean of Std. Dev. Within Replicates</strong>: The mean standard deviation within replicates of regulated proteins, on a log scale.</li>
<li><strong>Proportion of Proteins with Miscleaved Peptides</strong>: Measures the proportion of proteins with miscleaved peptides.</li>
<li><strong>Proportion of Regulated Proteins with Wrong Identified Peptides</strong>: Measures the proportion of regulated proteins with wrongly identified peptides, with FDR &lt; 0.01/0.05.</li>
<li><strong>Distribution of Quantitative Values (Skewness)</strong>: Measures how asymmetric the distribution of quantitative values is at the protein level.</li>
<li><strong>Distribution of Quantitative Values (Kurtosis)</strong>: Measures how normal (peaked) the distribution of quantitative values is at the protein level.</li>
<li><strong>Distribution of Quantitative Values (Standard Deviation)</strong>: Measures how broad the distribution of quantitative values is at the protein level.</li>
</ul>
</section>
<section id="ptm-level" class="level3">
<h3 class="anchored" data-anchor-id="ptm-level">PTM Level</h3>
<ul>
<li><strong>Total Number and Mean of Quantitatively Represented Proteoforms per Protein</strong>: Includes protein groups, can only be calculated for in silico data.</li>
<li><strong>Number of Modified Peptides</strong>: Total number of modified peptides.</li>
<li><strong>Proportion of Modified Peptides with Identical Non-Modified Form</strong>: Measures the proportion of modified peptides that have an identical non-modified form.</li>
<li><strong>AUC of ROC Curve for Correct Differentially Regulated Modified Peptides</strong>: After adjusting for protein amount, the area under the ROC curve for correctly identifying differentially regulated modified peptides.</li>
<li><strong>True FDR for Estimated FDR</strong>: True false discovery rate for an estimated FDR of 0.01/0.05.</li>
<li><strong>TPR (True Positive Rate)</strong>: Found proportion of correct differentially regulated modified peptides, with FDR &lt; 0.05/0.01.</li>
<li><strong>Proportion of Wrongly Regulated Modified Peptides</strong>: Measures the proportion of wrongly regulated modified peptides, with FDR 0.01/0.05, no adjustment.</li>
<li><strong>Proportion of Modified Peptides with Quantified Non-Modified Protein</strong>: Measures the proportion of modified peptides that have a quantified non-modified protein.</li>
<li><strong>Sum of Squares of Residuals Towards Actual Fold-Changes</strong>: Only calculated for modified peptides.</li>
</ul>
</section>
</section>
<section id="overview-as-table" class="level2">
<h2 class="anchored" data-anchor-id="overview-as-table">Overview as table</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Benchmark Name</th>
<th>Description</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Total Number of Peptides</td>
<td>Counts both modified and non-modified peptides. Fixed PTMs are not considered “modified”.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Number of Proteins</td>
<td>Total number of all proteins, independently whether shared or uniquely identified.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Proportion of Unique Modified and Non-Modified Peptides</td>
<td>Measures the proportion of peptides that are unique and either modified or non-modified.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Total Number of Unique Stripped Sequences</td>
<td>Counts the unique sequences after removing modifications.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Percentage Missingness</td>
<td>Calculates the percentage of missing values in the data.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>AUC of ROC Curve for Correct Differentially Regulated Features</td>
<td>Area under the ROC curve for correctly identifying differentially regulated peptides.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>TPR (True Positive Rate)</td>
<td>Found proportion of correct differentially regulated peptides, with FDR &lt; 0.05/0.01.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>True FDR for Estimated FDR</td>
<td>True false discovery rate for an estimated FDR of 0.01/0.05.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Proportion of Cleaved Peptides</td>
<td>Proportion of peptides per number of miscleavages.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Retention Time Range</td>
<td>The range of retention times (max-min).</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Dynamic Range</td>
<td>The dynamic range of peptide intensities on a log2 scale (max-min).</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Number of Accepted PSMs</td>
<td>Count of accepted peptide-spectrum matches, based on scan numbers.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Sum of Squares Residuals Towards Actual Fold-Changes</td>
<td>Assigns mean fold-change for peptides with multiple assigned fold-changes, only calculated for the first 2 conditions.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Mean of Std. Dev. Within Replicates</td>
<td>The mean standard deviation within replicates of peptides with actual fold-changes, on a log scale.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Distribution of Quantitative Values (Skewness)</td>
<td>Measures how asymmetric the distribution of quantitative values is.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Distribution of Quantitative Values (Kurtosis)</td>
<td>Measures how normal (peaked) the distribution of quantitative values is.</td>
<td>Peptide Level</td>
</tr>
<tr class="odd">
<td>Distribution of Quantitative Values (Standard Deviation)</td>
<td>Measures how broad the distribution of quantitative values is.</td>
<td>Peptide Level</td>
</tr>
<tr class="even">
<td>Number of Quantified Protein Groups</td>
<td>Total number of quantified protein groups.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Proportion of Quantified Uniquely Identified Proteins</td>
<td>Measures the proportion of uniquely identified proteins that are quantified.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>Percentage Missingness</td>
<td>Calculates the percentage of missing values at the protein level.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Distribution of Non-Modified Peptides per Protein</td>
<td>Summarized by its mean, the distribution of non-modified peptides per protein.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>AUC of ROC Curve for Correct Differentially Regulated Features</td>
<td>Area under the ROC curve for correctly identifying differentially regulated proteins.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>True FDR for Estimated FDR</td>
<td>True false discovery rate for an estimated FDR of 0.01/0.05.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>TPR (True Positive Rate)</td>
<td>Found proportion of correct differentially regulated proteins, with FDR &lt; 0.05/0.01.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Sum of Squares Residuals Towards Actual Fold-Changes</td>
<td>Takes the first non-zero one in case of multiples.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>Dynamic Range</td>
<td>The dynamic range of protein intensities on a log2 scale (max-min).</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Mean of Std. Dev. Within Replicates</td>
<td>The mean standard deviation within replicates of regulated proteins, on a log scale.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>Proportion of Proteins with Miscleaved Peptides</td>
<td>Measures the proportion of proteins with miscleaved peptides.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Proportion of Regulated Proteins with Wrong Identified Peptides</td>
<td>Measures the proportion of regulated proteins with wrongly identified peptides, with FDR &lt; 0.01/0.05.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>Distribution of Quantitative Values (Skewness)</td>
<td>Measures how asymmetric the distribution of quantitative values is at the protein level.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Distribution of Quantitative Values (Kurtosis)</td>
<td>Measures how normal (peaked) the distribution of quantitative values is at the protein level.</td>
<td>Protein Level</td>
</tr>
<tr class="even">
<td>Distribution of Quantitative Values (Standard Deviation)</td>
<td>Measures how broad the distribution of quantitative values is at the protein level.</td>
<td>Protein Level</td>
</tr>
<tr class="odd">
<td>Total Number and Mean of Quantitatively Represented Proteoforms per Protein</td>
<td>Includes protein groups, can only be calculated for in silico data.</td>
<td>PTM Level</td>
</tr>
<tr class="even">
<td>Number of Modified Peptides</td>
<td>Total number of modified peptides.</td>
<td>PTM Level</td>
</tr>
<tr class="odd">
<td>Proportion of Modified Peptides with Identical Non-Modified Form</td>
<td>Measures the proportion of modified peptides that have an identical non-modified form.</td>
<td>PTM Level</td>
</tr>
<tr class="even">
<td>AUC of ROC Curve for Correct Differentially Regulated Modified Peptides</td>
<td>After adjusting for protein amount, the area under the ROC curve for correctly identifying differentially regulated modified peptides.</td>
<td>PTM Level</td>
</tr>
<tr class="odd">
<td>True FDR for Estimated FDR</td>
<td>True false discovery rate for an estimated FDR of 0.01/0.05.</td>
<td>PTM Level</td>
</tr>
<tr class="even">
<td>TPR (True Positive Rate)</td>
<td>Found proportion of correct differentially regulated modified peptides, with FDR &lt; 0.05/0.01.</td>
<td>PTM Level</td>
</tr>
<tr class="odd">
<td>Proportion of Wrongly Regulated Modified Peptides</td>
<td>Measures the proportion of wrongly regulated modified peptides, with FDR 0.01/0.05, no adjustment.</td>
<td>PTM Level</td>
</tr>
<tr class="even">
<td>Proportion of Modified Peptides with Quantified Non-Modified Protein</td>
<td>Measures the proportion of modified peptides that have a quantified non-modified protein.</td>
<td>PTM Level</td>
</tr>
<tr class="odd">
<td>Sum of Squares of Residuals Towards Actual Fold-Changes</td>
<td>Only calculated for modified peptides.</td>
<td>PTM Level</td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>