<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ProteoMaker Benchmarks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Benchmarks_files/libs/clipboard/clipboard.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/quarto.js"></script>
<script src="Benchmarks_files/libs/quarto-html/popper.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Benchmarks_files/libs/quarto-html/anchor.min.js"></script>
<link href="Benchmarks_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Benchmarks_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Benchmarks_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Benchmarks_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Benchmarks_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ProteoMaker Benchmarks</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This document provides a detailed description of the benchmarks used in the ProteoMaker pipeline. ProteoMaker is a tool for generating an in-silico bottom-up LC-MS dataset from proteoforms. The pipeline simulates various stages of the experimental process, from the generation of ground truth data to mass spectrometry (MS) analysis and statistical testing. These benchmarks are essential for comparing the results and evaluating the performance of the pipeline. For more information about the project, visit <a href="https://github.com/computproteomics/ProteoMaker">ProteoMaker on GitHub</a>.</p>
<section id="list-of-benchmarks" class="level2">
<h2 class="anchored" data-anchor-id="list-of-benchmarks">List of Benchmarks</h2>
<p>The following values and distributions are collected and used for assessing quantitative and statistical fidelity of the simulation and benchmarking pipeline.</p>
<section id="peptidoform-level" class="level3">
<h3 class="anchored" data-anchor-id="peptidoform-level">Peptidoform Level</h3>
<ul>
<li><p><strong>Total Number of Peptidoforms</strong> (<code>numPeptides</code>, label: <strong>#Total peptidoforms (mod+unmod)</strong>): Total count of all peptidoforms (modified and unmodified). Fixed PTMs are not included.</p></li>
<li><p><strong>Number of Protein Accessions</strong> (<code>numProteins</code>, label: <strong>#Protein accessions (all peptidoforms)</strong>): Distinct protein accessions represented by at least one peptidoform.</p></li>
<li><p><strong>Proportion of Unique Peptidoforms</strong> (<code>propUniquePep</code>, label: <strong>% Unique peptidoforms (single protein)</strong>): Fraction of peptidoforms mapping to exactly one protein accession.</p></li>
<li><p><strong>Total Number of Unique Peptide Sequences</strong> (<code>uniqueStrippedPep</code>, label: <strong>#Unique peptide sequences</strong>): Unique peptide sequences after removing PTM annotations.</p></li>
<li><p><strong>Percentage Missingness</strong> (<code>percMissingPep</code>, label: <strong>% Missing peptidoform values</strong>): Percentage of missing values across peptidoform-level intensities.</p></li>
<li><p><strong>AUC of ROC Curve for Correct Differentially Regulated Peptidoforms</strong> (<code>aucDiffRegPeptides.FDR_limma 2 vs 1.AUC</code>, label: <em>Peptidoform AUC (truth vs limma FDR)</em>): Area under the ROC curve for identifying truly regulated peptidoforms using the limma-based FDR estimates.</p></li>
<li><p><strong>TPR (True Positive Rate)</strong> (<code>tprPep0.01.FDR_limma 2 vs 1.TPR</code>, <code>tprPep0.05.FDR_limma 2 vs 1.TPR</code>, label: <em>TPR peptidoforms (FDR &lt; 0.01/0.05)</em>): True positive rate at estimated FDR thresholds of 0.01 and 0.05.</p></li>
<li><p><strong>True FDR for Estimated FDR</strong> (<code>tFDRPep0.01.FDR_limma 2 vs 1.tFDR</code>, <code>tFDRPep0.05.FDR_limma 2 vs 1.tFDR</code>, label: <em>True FDR (peptidoforms)</em>): Actual (true) FDR at estimated FDR levels of 0.01 and 0.05.</p></li>
<li><p><strong>Miscleavage Count Distribution</strong> (<code>propMisCleavedPeps</code>, label: <em>Miscleavage distribution</em>): Vector of proportions for peptides grouped by their number of missed cleavages (e.g., fractions for 0, 1, 2, … missed cleavages).</p></li>
<li><p><strong>Dynamic Range</strong> (<code>dynRangePep</code>, label: <em>Dynamic range (peptidoforms)</em>): Log2 range of peptidoform intensities.</p></li>
<li><p><strong>Mean of Squared Residuals Towards Actual Fold-Changes</strong> (<code>meanSquareDiffFCPep</code>, label: <em>Fold-change error (peptidoforms)</em>): Fold-change error (ground truth vs.&nbsp;measured), computed as squared differences for log2 FC.</p></li>
<li><p><strong>Mean of Std. Dev. Within Replicates</strong> (<code>sdWithinRepsPep</code>, label: <em>Replicate SD (peptidoforms)</em>): Within-group variation of regulated peptidoforms.</p></li>
<li><p><strong>Skewness</strong> (<code>skewnessPeps</code>, label: <em>Skewness (peptidoforms)</em>): Asymmetry of peptidoform intensity distribution.</p></li>
<li><p><strong>Kurtosis</strong> (<code>kurtosisPeps</code>, label: <em>Kurtosis (peptidoforms)</em>): Peakedness (tailedness) of peptidoform intensity distribution.</p></li>
<li><p><strong>Standard Deviation</strong> (<code>sdPeps</code>, label: <em>Overall SD (peptidoforms)</em>): Spread of peptidoform intensity distribution.</p></li>
</ul>
</section>
<section id="protein-group-level" class="level3">
<h3 class="anchored" data-anchor-id="protein-group-level">Protein-Group Level</h3>
<ul>
<li><p><strong>Number of Quantified Protein Groups</strong> (<code>numQuantProtGroups</code>, label: <strong>#Quantified protein groups</strong>): Count of protein groups that passed summarisation (respecting the configured shared/modified peptide settings) and retain at least one quantified value.</p></li>
<li><p><strong>Proportion of Single-Protein Groups</strong> (<code>propUniqueProts</code>, label: <strong>% Single-protein groups</strong>): Fraction of protein groups with a single protein accession.</p></li>
<li><p><strong>Percentage Missingness</strong> (<code>percMissingProt</code>, label: <strong>% Missing protein-group values</strong>): Missingness of values across protein-group intensities.</p></li>
<li><p><strong>Mean Number of Peptide Sequences per Protein Group</strong> (<code>meanPepPerProt</code>, label: <em>Peptide sequences per protein group</em>): Mean count of peptide sequences per quantified protein group.</p></li>
<li><p><strong>AUC of ROC Curve for Correct Differentially Regulated Features</strong> (<code>aucDiffRegProteins.FDR_PolySTest 2 vs 1.AUC</code>, label: <em>Protein-group AUC (truth vs FDR)</em>): AUC for identifying differentially regulated protein groups, applying PolySTest.</p></li>
<li><p><strong>TPR (True Positive Rate)</strong> (<code>tprProt0.01.FDR_PolySTest 2 vs 1.TPR</code>, <code>tprProt0.05.FDR_PolySTest 2 vs 1.TPR</code>, label: <em>TPR protein groups (FDR &lt; 0.01/0.05)</em>): True positive rate for regulated protein groups at PolySTest-estimated FDR thresholds of 0.01 and 0.05.</p></li>
<li><p><strong>True FDR for Estimated FDR</strong> (<code>tFDRProt0.01.FDR_PolySTest 2 vs 1.tFDR</code>, <code>tFDRProt0.05.FDR_PolySTest 2 vs 1.tFDR</code>, label: <em>True FDR (protein groups)</em>): Actual false-discovery rate realised at those PolySTest thresholds.</p></li>
<li><p><strong>Mean of Squared Residuals Towards Actual Fold-Changes</strong> (<code>meanSquareDiffFCProt</code>, label: <em>Fold-change error (protein groups)</em>): Average squared error between simulated and measured log2 fold-changes.</p></li>
<li><p><strong>Dynamic Range</strong> (<code>dynRangeProt</code>, label: <em>Dynamic range (protein groups)</em>): Log2 range of protein-group intensities.</p></li>
<li><p><strong>Mean of Std. Dev. Within Replicates</strong> (<code>sdWithinRepsProt</code>, label: <em>Replicate SD (protein groups)</em>): Within-group variation of regulated protein groups.</p></li>
<li><p><strong>Proportion of Protein Groups with Miscleaved Peptides</strong> (<code>propMisCleavedProts</code>, label: <strong>% Miscleaved protein groups</strong>): Fraction of quantified protein groups that contain at least one peptide with a missed cleavage.</p></li>
<li><p><strong>Proportion of Regulated Protein Groups with Wrong Identified Peptides</strong> (<code>propDiffRegWrongIDProt0.01.FDR_PolySTest 2 vs 1</code>, <code>propDiffRegWrongIDProt0.05.FDR_PolySTest 2 vs 1</code>, label: <strong>% Wrong-ID (protein groups)</strong>): Fraction of regulated protein groups with wrongly identified peptides at 0.01 and 0.05 PolySTest FDR thresholds.</p></li>
<li><p><strong>Skewness</strong> (<code>skewnessProts</code>, label: <em>Skewness (protein groups)</em>): Asymmetry in distribution of protein-group intensities.</p></li>
<li><p><strong>Kurtosis</strong> (<code>kurtosisProts</code>, label: <em>Kurtosis (protein groups)</em>): Peakedness of protein-group intensity distribution.</p></li>
<li><p><strong>Standard Deviation</strong> (<code>sdProts</code>, label: <em>Overall SD (protein groups)</em>): Overall spread of protein-group intensity values.</p></li>
</ul>
</section>
<section id="proteoform-level" class="level3">
<h3 class="anchored" data-anchor-id="proteoform-level">Proteoform Level</h3>
<ul>
<li><p><strong>Number and Mean of Proteoforms per Protein</strong> (<code>numProteoforms</code>, <code>meanProteoformsPerProt</code>, label: <strong>#Proteoforms</strong>, <em>Proteoforms per protein</em>): Total and mean count of distinct proteoforms across protein groups.</p></li>
<li><p><strong>Number of Modified Peptidoforms</strong> (<code>numModPeptides</code>, label: <strong>#Modified peptidoforms</strong>): Total count of peptidoforms carrying simulated PTMs.</p></li>
<li><p><strong>Proportion of Modified Peptidoforms with Identical Unmodified Form</strong> (<code>propModAndUnmodPep</code>, label: <strong>% Modified with unmodified match</strong>): Fraction of modified peptidoforms that have a corresponding unmodified form.</p></li>
<li><p><strong>AUC for Correctly Regulated Modified Peptidoforms</strong> (<code>aucDiffRegAdjModPep.FDR_limma 2 vs 1.AUC</code>, label: <em>AUC (adj. mod. peptidoforms)</em>): AUC calculated after adjustment for parent protein abundance (reported only when at least 200 modified peptidoforms have matching protein quantification).</p></li>
<li><p><strong>TPR</strong> (<code>tprAdjModPep0.01.FDR_limma 2 vs 1.TPR</code>, <code>tprAdjModPep0.05.FDR_limma 2 vs 1.TPR</code>, label: <em>TPR (adj. mod. peptidoforms)</em>): True positive rate for regulated modified peptidoforms at estimated FDRs 0.01 and 0.05.</p></li>
<li><p><strong>True FDR</strong> (<code>tFDRAdjModPep0.01.FDR_limma 2 vs 1.tFDR</code>, <code>tFDRAdjModPep0.05.FDR_limma 2 vs 1.tFDR</code>, label: <em>True FDR (mod. peptidoforms)</em>): Actual FDR of modified peptidoform results at FDRs 0.01 and 0.05.</p></li>
<li><p><strong>Share of Significant Modified Peptidoforms</strong> (<code>propDiffRegPepWrong0.01.FDR_PolySTest 2 vs 1</code>, <code>propDiffRegPepWrong0.05.FDR_PolySTest 2 vs 1</code>, label: <strong>% Wrongly significant (mod. peptidoforms)</strong>): Fraction of modified peptidoforms whose FDR values fall below 0.01 or 0.05, respectively.</p></li>
<li><p><strong>Proportion of Modified Peptidoforms with Quantified Protein Group</strong> (<code>percOverlapModPepProt</code>, label: <strong>% Mod peptidoforms with protein quant</strong>): Fraction of modified peptidoforms with quantifiable protein-group background.</p></li>
<li><p><strong>Mean of Squared Residuals Towards Actual Fold-Changes</strong> (<code>meanSquareDiffFCModPep</code>, label: <em>Fold-change error (mod. peptidoforms)</em>): Squared differences between simulated and measured log2 fold-changes of modified peptidoforms.</p></li>
</ul>
</section>
</section>
<section id="benchmark-overview-table" class="level2">
<h2 class="anchored" data-anchor-id="benchmark-overview-table">Benchmark Overview Table</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Benchmarking Metrics</th>
<th>Name</th>
<th>Label (for figures)</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Total Number of Peptidoforms</td>
<td>numPeptides</td>
<td>#Total peptidoforms (mod+unmod)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>Number of Protein Accessions</td>
<td>numProteins</td>
<td>#Protein accessions (all peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Proportion of Unique Peptidoforms</td>
<td>propUniquePep</td>
<td>% Unique peptidoforms (single protein)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>Unique Peptide Sequences</td>
<td>uniqueStrippedPep</td>
<td>#Unique peptide sequences</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Percentage Missingness</td>
<td>percMissingPep</td>
<td>% Missing peptidoform values</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>AUC of ROC (Peptidoforms)</td>
<td>aucDiffRegPeptides.FDR_limma 2 vs 1.AUC</td>
<td>Peptidoform AUC (truth vs limma FDR)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>TPR at FDR &lt; 0.01</td>
<td>tprPep0.01.FDR_limma 2 vs 1.TPR</td>
<td>TPR peptidoforms (FDR &lt; 0.01)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>TPR at FDR &lt; 0.05</td>
<td>tprPep0.05.FDR_limma 2 vs 1.TPR</td>
<td>TPR peptidoforms (FDR &lt; 0.05)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>True FDR at 0.01</td>
<td>tFDRPep0.01.FDR_limma 2 vs 1.tFDR</td>
<td>True FDR (peptidoforms, 0.01)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>True FDR at 0.05</td>
<td>tFDRPep0.05.FDR_limma 2 vs 1.tFDR</td>
<td>True FDR (peptidoforms, 0.05)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Miscleavage Distribution</td>
<td>propMisCleavedPeps.{0,1,…}</td>
<td>Miscleavage distribution (per missed-cleavage count)</td>
<td>Peptide</td>
</tr>
<tr class="even">
<td>Dynamic Range</td>
<td>dynRangePep</td>
<td>Dynamic range (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Fold-Change Error</td>
<td>meanSquareDiffFCPep</td>
<td>Fold-change error (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>Within-Replicate SD</td>
<td>sdWithinRepsPep</td>
<td>Replicate SD (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Skewness</td>
<td>skewnessPeps</td>
<td>Skewness (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>Kurtosis</td>
<td>kurtosisPeps</td>
<td>Kurtosis (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="odd">
<td>Overall SD</td>
<td>sdPeps</td>
<td>Overall SD (peptidoforms)</td>
<td>Peptidoform</td>
</tr>
<tr class="even">
<td>Quantified Protein Groups</td>
<td>numQuantProtGroups</td>
<td>#Quantified protein groups</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Single-Protein Groups</td>
<td>propUniqueProts</td>
<td>% Single-protein groups</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>Percentage Missingness</td>
<td>percMissingProt</td>
<td>% Missing protein-group values</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Mean Peptide Sequences per Protein Group</td>
<td>meanPepPerProt</td>
<td>Peptide sequences per protein group</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>AUC of ROC (Protein Groups)</td>
<td>aucDiffRegProteins.FDR_PolySTest 2 vs 1.AUC</td>
<td>Protein-group AUC (truth vs FDR)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>TPR at FDR &lt; 0.01</td>
<td>tprProt0.01.FDR_PolySTest 2 vs 1.TPR</td>
<td>TPR protein groups (FDR &lt; 0.01)</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>TPR at FDR &lt; 0.05</td>
<td>tprProt0.05.FDR_PolySTest 2 vs 1.TPR</td>
<td>TPR protein groups (FDR &lt; 0.05)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>True FDR at 0.01</td>
<td>tFDRProt0.01.FDR_PolySTest 2 vs 1.tFDR</td>
<td>True FDR (protein groups, 0.01)</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>True FDR at 0.05</td>
<td>tFDRProt0.05.FDR_PolySTest 2 vs 1.tFDR</td>
<td>True FDR (protein groups, 0.05)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Fold-Change Error</td>
<td>meanSquareDiffFCProt</td>
<td>Fold-change error (protein groups)</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>Within-Replicate SD</td>
<td>sdWithinRepsProt</td>
<td>Replicate SD (protein groups)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Miscleaved Protein Groups</td>
<td>propMisCleavedProts</td>
<td>% Miscleaved protein groups</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>Wrong ID Protein Groups at 0.01</td>
<td>propDiffRegWrongIDProt0.01.FDR_PolySTest 2 vs 1</td>
<td>% Wrong-ID (protein groups, 0.01)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Wrong ID Protein Groups at 0.05</td>
<td>propDiffRegWrongIDProt0.05.FDR_PolySTest 2 vs 1</td>
<td>% Wrong-ID (protein groups, 0.05)</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>Skewness</td>
<td>skewnessProts</td>
<td>Skewness (protein groups)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Kurtosis</td>
<td>kurtosisProts</td>
<td>Kurtosis (protein groups)</td>
<td>Protein group</td>
</tr>
<tr class="even">
<td>Overall SD</td>
<td>sdProts</td>
<td>Overall SD (protein groups)</td>
<td>Protein group</td>
</tr>
<tr class="odd">
<td>Total Proteoforms</td>
<td>numProteoforms</td>
<td>#Proteoforms</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>Mean Proteoforms per Protein</td>
<td>meanProteoformsPerProt</td>
<td>Proteoforms per protein</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>Number of Modified Peptidoforms</td>
<td>numModPeptides</td>
<td>#Modified peptidoforms</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>Modified with Unmodified Match</td>
<td>propModAndUnmodPep</td>
<td>% Modified with unmodified match</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>AUC (Adj. Modified Peptidoforms)</td>
<td>aucDiffRegAdjModPep.FDR_limma 2 vs 1.AUC</td>
<td>AUC (adj. mod. peptidoforms)</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>TPR (Adj. Mod Peptidoforms) at 0.01</td>
<td>tprAdjModPep0.01.FDR_limma 2 vs 1.TPR</td>
<td>TPR (adj. mod. peptidoforms, 0.01)</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>TPR (Adj. Mod Peptidoforms) at 0.05</td>
<td>tprAdjModPep0.05.FDR_limma 2 vs 1.TPR</td>
<td>TPR (adj. mod. peptidoforms, 0.05)</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>True FDR (Adj. Mod Peptidoforms) at 0.01</td>
<td>tFDRAdjModPep0.01.FDR_limma 2 vs 1.tFDR</td>
<td>True FDR (mod. peptidoforms, 0.01)</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>True FDR (Adj. Mod Peptidoforms) at 0.05</td>
<td>tFDRAdjModPep0.05.FDR_limma 2 vs 1.tFDR</td>
<td>True FDR (mod. peptidoforms, 0.05)</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>Wrongly Significant Mod Peptidoforms (0.01)</td>
<td>propDiffRegPepWrong0.01.FDR_PolySTest 2 vs 1</td>
<td>% Wrongly significant (mod. peptidoforms, 0.01)</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>Wrongly Significant Mod Peptidoforms (0.05)</td>
<td>propDiffRegPepWrong0.05.FDR_PolySTest 2 vs 1</td>
<td>% Wrongly significant (mod. peptidoforms, 0.05)</td>
<td>Proteoform</td>
</tr>
<tr class="even">
<td>Modified Peptidoforms with Protein Quant</td>
<td>percOverlapModPepProt</td>
<td>% Mod peptidoforms with protein quant</td>
<td>Proteoform</td>
</tr>
<tr class="odd">
<td>Fold-Change Error (Mod Peptidoforms)</td>
<td>meanSquareDiffFCModPep</td>
<td>Fold-change error (mod. peptidoforms)</td>
<td>Proteoform</td>
</tr>
</tbody>
</table>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>